#!/bin/bash

# Multi-Repository Branch Synchronization Script
# Usage: multi-repo-sync <branch-pattern> [options]
# This script changes branches across all configured repositories using pattern matching,
# fetches/pulls updates, and optionally installs dependencies.

set -e  # Exit on error

# Script configuration
SCRIPT_PATH="$(realpath "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
CONFIG_FILE="$HOME/.multi-repo-sync.conf"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Default options
BRANCH_PATTERN=""
INSTALL_DEPS=false
CREATE_ALIAS=false
CONFIGURE=false
SHOW_STATUS=false
DRY_RUN=false
SHOW_VERSION=false

# Repository configuration (will be loaded from config file)
declare -A REPO_PATHS
declare -A REPO_ENABLED
declare -a REPO_ORDER

# Load configuration file
load_config() {
  if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
    return 0
  fi
  return 1
}

# Get version from git tags
get_version() {
  if [ -d "$SCRIPT_DIR/.git" ]; then
    # Try to get the latest tag
    local tag=$(cd "$SCRIPT_DIR" && git describe --tags --abbrev=0 2>/dev/null)
    if [ -n "$tag" ]; then
      echo "$tag"
    else
      # If no tags, use commit hash
      echo "dev-$(cd "$SCRIPT_DIR" && git rev-parse --short HEAD 2>/dev/null || echo 'unknown')"
    fi
  else
    echo "unknown"
  fi
}

# Show version
show_version() {
  local version=$(get_version)
  echo -e "${BLUE}Multi-Repo Sync${NC} version ${YELLOW}$version${NC}"
  exit 0
}

# Create default configuration with generic example
create_default_config() {
  cat > "$CONFIG_FILE" << 'EOF'
# Multi-Repo Sync Configuration File
# This file defines the repositories to synchronize

# Repository paths (key=name, value=absolute path)
# Example: REPO_PATHS["repo1"]="$HOME/projects/repo1"
REPO_PATHS["repo1"]="$HOME/repos/repository-one"
REPO_PATHS["repo2"]="$HOME/repos/repository-two"
REPO_PATHS["repo3"]="$HOME/repos/repository-three"

# Enable/disable repositories (true/false)
REPO_ENABLED["repo1"]=true
REPO_ENABLED["repo2"]=true
REPO_ENABLED["repo3"]=true

# Order of synchronization (space-separated list)
REPO_ORDER=("repo1" "repo2" "repo3")
EOF
}

# Interactive configuration
configure_repos() {
  echo -e "${BLUE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
  echo -e "${BLUE}‚ïë        Multi-Repo Sync - Interactive Configuration         ‚ïë${NC}"
  echo -e "${BLUE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
  echo ""
  echo -e "${CYAN}This will create a configuration file at: ${YELLOW}$CONFIG_FILE${NC}"
  echo ""
  
  # Ask for base directory
  local default_base="$HOME/repos"
  echo -e "${YELLOW}Enter the base directory where your repositories are located:${NC}"
  read -p "[$default_base]: " base_dir
  base_dir="${base_dir:-$default_base}"
  
  # Expand ~ to $HOME
  base_dir="${base_dir/#\~/$HOME}"
  
  echo ""
  echo -e "${CYAN}Configuring repositories...${NC}"
  echo -e "${YELLOW}(Press Enter to accept default, or type custom path)${NC}"
  echo ""
  
  echo -e "${YELLOW}Enter repositories (leave key empty to finish):${NC}"
  
  declare -A new_paths
  declare -A new_enabled
  declare -a new_order
  
  local repos=()
  
  while true; do
    echo -e "${BLUE}‚ñ∏ Repository${NC}"
    read -p "  Key (e.g., 'frontend', 'api', leave empty to finish): " repo_key
    
    if [ -z "$repo_key" ]; then
      echo ""
      break
    fi
    
    read -p "  Display name: " repo_name
    repo_name="${repo_name:-$repo_key}"
    read -p "  Full path (or directory name under $base_dir): " repo_path
    
    if [ -z "$repo_path" ]; then
      echo -e "  ${RED}‚úó Path cannot be empty, skipping${NC}"
      echo ""
      continue
    fi
    
    # Check if it's a full path or relative
    if [[ "$repo_path" == /* ]]; then
      repo_path="${repo_path/#\~/$HOME}"
    else
      repo_path="$base_dir/$repo_path"
    fi
    
    repos+=("$repo_key:$repo_name:$repo_path")
    echo -e "  ${GREEN}‚úì Added${NC}"
    echo ""
  done
  
  # If no repositories were added, create example configuration
  if [ ${#repos[@]} -eq 0 ]; then
    echo -e "${YELLOW}No repositories configured. Creating example configuration...${NC}"
    repos=(
      "repo1:Repository One:repository-one"
      "repo2:Repository Two:repository-two"
      "repo3:Repository Three:repository-three"
    )
  fi
  
  for repo_info in "${repos[@]}"; do
    IFS=':' read -r key name default_dir <<< "$repo_info"
    
    # Check if it's a full path or just directory name
    local default_path
    if [[ "$default_dir" == /* ]]; then
      default_path="$default_dir"
    else
      default_path="$base_dir/$default_dir"
    fi
    
    echo -e "${BLUE}‚ñ∏ ${name}${NC}"
    
    # Ask for path
    read -p "  Path [$default_path]: " custom_path
    custom_path="${custom_path:-$default_path}"
    custom_path="${custom_path/#\~/$HOME}"
    
    # Ask if enabled
    read -p "  Enable this repository? [Y/n]: " enabled
    enabled="${enabled:-Y}"
    
    if [[ "$enabled" =~ ^[Yy]$ ]]; then
      new_paths["$key"]="$custom_path"
      new_enabled["$key"]="true"
      new_order+=("$key")
      echo -e "  ${GREEN}‚úì Enabled${NC}"
    else
      new_paths["$key"]="$custom_path"
      new_enabled["$key"]="false"
      echo -e "  ${YELLOW}‚óã Disabled${NC}"
    fi
    echo ""
  done
  
  # Write configuration file
  cat > "$CONFIG_FILE" << EOF
# Multi-Repo Sync Configuration File
# Generated on $(date)
# Edit this file to customize repository paths and settings

# Repository paths (key=name, value=absolute path)
EOF
  
  for key in "${!new_paths[@]}"; do
    echo "REPO_PATHS[\"$key\"]=\"${new_paths[$key]}\"" >> "$CONFIG_FILE"
  done
  
  echo "" >> "$CONFIG_FILE"
  echo "# Enable/disable repositories (true/false)" >> "$CONFIG_FILE"
  for key in "${!new_enabled[@]}"; do
    echo "REPO_ENABLED[\"$key\"]=\"${new_enabled[$key]}\"" >> "$CONFIG_FILE"
  done
  
  echo "" >> "$CONFIG_FILE"
  echo "# Order of synchronization (space-separated list)" >> "$CONFIG_FILE"
  echo "REPO_ORDER=(${new_order[@]})" >> "$CONFIG_FILE"
  
  echo -e "${GREEN}‚úì Configuration saved to: ${YELLOW}$CONFIG_FILE${NC}"
  echo ""
  
  # Validate paths
  echo -e "${CYAN}Validating repository paths...${NC}"
  local all_valid=true
  for key in "${new_order[@]}"; do
    local path="${new_paths[$key]}"
    if [ -d "$path" ]; then
      echo -e "  ${GREEN}‚úì${NC} $key: $path"
    else
      echo -e "  ${RED}‚úó${NC} $key: $path ${RED}(not found)${NC}"
      all_valid=false
    fi
  done
  
  echo ""
  if [ "$all_valid" = false ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  Some repository paths don't exist yet.${NC}"
    echo -e "${YELLOW}   You can edit the configuration later: ${CYAN}$CONFIG_FILE${NC}"
  fi
  echo ""
}

# Show current configuration
show_config() {
  if [ ! -f "$CONFIG_FILE" ]; then
    echo -e "${RED}‚ùå Configuration file not found: $CONFIG_FILE${NC}"
    echo -e "${YELLOW}Run: multi-repo-sync --configure${NC}"
    return 1
  fi
  
  load_config
  
  echo -e "${BLUE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
  echo -e "${BLUE}‚ïë            Current Multi-Repo Sync Configuration              ‚ïë${NC}"
  echo -e "${BLUE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
  echo ""
  echo -e "${CYAN}Configuration file: ${YELLOW}$CONFIG_FILE${NC}"
  echo ""
  echo -e "${CYAN}Repositories:${NC}"
  
  for key in "${REPO_ORDER[@]}"; do
    local path="${REPO_PATHS[$key]}"
    local enabled="${REPO_ENABLED[$key]}"
    local status="${GREEN}‚úì Enabled${NC}"
    
    if [ "$enabled" != "true" ]; then
      status="${YELLOW}‚óã Disabled${NC}"
    fi
    
    local exists="${GREEN}[exists]${NC}"
    if [ ! -d "$path" ]; then
      exists="${RED}[not found]${NC}"
    fi
    
    echo -e "  $status  ${BLUE}$key${NC}"
    echo -e "           $path $exists"
  done
  
  echo ""
}

# Show current status (branches) without switching
show_status() {
  if ! load_config; then
    echo -e "${RED}‚ùå Configuration file not found: $CONFIG_FILE${NC}"
    echo -e "${YELLOW}Run: multi-repo-sync --configure${NC}"
    exit 1
  fi
  
  echo -e "${BLUE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
  echo -e "${BLUE}‚ïë                  Repositories Status                        ‚ïë${NC}"
  echo -e "${BLUE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
  echo ""
  
  for key in "${REPO_ORDER[@]}"; do
    if [ "${REPO_ENABLED[$key]}" != "true" ]; then
      continue
    fi
    
    repo="${REPO_PATHS[$key]}"
    
    if [ ! -d "$repo" ]; then
      echo -e "  ${RED}‚úó${NC} $(printf '%-25s' "$key"): ${RED}[not found]${NC}"
      continue
    fi
    
    cd "$repo"
    current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "?")
    
    # Check if there are uncommitted changes
    if ! git diff-index --quiet HEAD 2>/dev/null; then
      status="${YELLOW}[modified]${NC}"
    else
      status=""
    fi
    
    # Check if behind/ahead of origin
    git fetch origin --quiet 2>/dev/null
    local_commit=$(git rev-parse HEAD 2>/dev/null)
    remote_commit=$(git rev-parse origin/$current_branch 2>/dev/null)
    
    if [ "$local_commit" != "$remote_commit" ] && [ -n "$remote_commit" ]; then
      behind=$(git rev-list --count HEAD..origin/$current_branch 2>/dev/null || echo 0)
      ahead=$(git rev-list --count origin/$current_branch..HEAD 2>/dev/null || echo 0)
      
      if [ "$behind" -gt 0 ]; then
        status="$status ${CYAN}‚Üì$behind${NC}"
      fi
      if [ "$ahead" -gt 0 ]; then
        status="$status ${CYAN}‚Üë$ahead${NC}"
      fi
    fi
    
    echo -e "  ${GREEN}‚úì${NC} $(printf '%-25s' "$key"): ${YELLOW}$current_branch${NC} $status"
  done
  
  echo ""
  echo -e "${CYAN}Legend: ${YELLOW}[modified]${NC} = local changes | ${CYAN}‚ÜìN${NC} = behind by N commits | ${CYAN}‚ÜëN${NC} = ahead by N commits${NC}"
  echo ""
  exit 0
}

# Show help menu
show_help() {
  echo -e "${BLUE}Multi-Repository Branch Synchronization Script${NC}"
  echo ""
  echo -e "${YELLOW}USAGE:${NC}"
  echo "  multi-repo-sync <branch-pattern> [options]"
  echo "  multi-repo-sync [options] -b <branch-pattern>"
  echo "  multi-repo-sync --status"
  echo ""
  echo -e "${YELLOW}DESCRIPTION:${NC}"
  echo "  Synchronizes all configured repositories to branches matching the given pattern."
  echo "  The script searches for branches that start with the pattern (e.g., 'feature/888')"
  echo "  and automatically handles different suffixes in each repository."
  echo ""
  echo -e "${YELLOW}ARGUMENTS:${NC}"
  echo "  <branch-pattern>    Branch pattern to search for (e.g., 'feature/888', 'fix/123')"
  echo "                      Can be the first positional argument or specified with -b/--branch"
  echo ""
  echo -e "${YELLOW}OPTIONS:${NC}"
  echo "  -b, --branch <pattern>     Specify branch pattern explicitly"
  echo "  -d, --dependencies         Install/update dependencies (default: skip)"
  echo "      --dry-run              Preview what would happen without making changes"
  echo "  -i, --install              Create bash alias for this script"
  echo "  -c, --configure            Configure repository paths interactively"
  echo "  -s, --show-config          Show current configuration"
  echo "      --status               Show current branch status for all repositories"
  echo "  -v, --version              Show version information"
  echo "  -h, --help                 Show this help message"
  echo ""
  echo -e "${YELLOW}CONFIGURATION:${NC}"
  echo -e "  Configuration file: ${CYAN}~/.multi-repo-sync.conf${NC}"
  echo ""
  echo "  The configuration file defines:"
  echo "  - Repository paths (can be anywhere in your system)"
  echo "  - Which repositories to synchronize"
  echo "  - Order of synchronization"
  echo ""
  echo -e "  ${CYAN}To add custom repositories:${NC} Edit the config file or run ${YELLOW}multi-repo-sync --configure${NC}"
  echo ""
  echo -e "${YELLOW}EXAMPLES:${NC}"
  echo -e "  ${CYAN}# First time setup${NC}"
  echo "  multi-repo-sync --configure           # Configure repository paths"
  echo "  multi-repo-sync --install             # Create bash alias (e.g., mrsync)"
  echo ""
  echo -e "  ${CYAN}# Daily usage${NC}"
  echo "  mrsync status                         # Check current branches"
  echo "  mrsync feature/888 --dry-run          # Preview what would happen"
  echo "  mrsync feature/888                    # Switch to feature/888* branches"
  echo "  mrsync develop -d                     # Switch to develop and install dependencies"
  echo "  mrsync -b fix/123 --dependencies      # Switch to fix/123* with dependencies"
  echo ""
  echo -e "  ${CYAN}# Configuration management${NC}"
  echo "  mrsync --show-config                  # View current configuration"
  echo "  mrsync --configure                    # Reconfigure paths"
  echo "  mrsync --version                      # Show version"
  echo ""
  echo -e "${YELLOW}SHARING WITH TEAMMATES:${NC}"
  echo "  1. Share this script file"
  echo "  2. Each person runs: multi-repo-sync --configure"
  echo "  3. Configure their local repository paths"
  echo "  4. Create alias: multi-repo-sync --install"
  echo ""
  exit 0
}

# Create bash alias
create_alias() {
  local shell_rc=""
  local alias_name="mrsync"
  
  echo -e "${BLUE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
  echo -e "${BLUE}‚ïë                  Alias Installation                          ‚ïë${NC}"
  echo -e "${BLUE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
  echo ""
  
  # Ask for custom alias name
  echo -e "${CYAN}Enter the alias name you want to use:${NC}"
  read -p "[$alias_name]: " custom_alias
  alias_name="${custom_alias:-$alias_name}"
  echo ""
  
  # Make script executable
  echo -e "${CYAN}Making script executable...${NC}"
  chmod +x "$SCRIPT_PATH"
  echo -e "${GREEN}‚úì Script is now executable${NC}"
  echo ""
  
  # Detect shell configuration file
  if [ -n "$BASH_VERSION" ]; then
    if [ -f "$HOME/.bashrc" ]; then
      shell_rc="$HOME/.bashrc"
    elif [ -f "$HOME/.bash_profile" ]; then
      shell_rc="$HOME/.bash_profile"
    fi
  elif [ -n "$ZSH_VERSION" ]; then
    shell_rc="$HOME/.zshrc"
  fi
  
  if [ -z "$shell_rc" ]; then
    echo -e "${RED}‚ùå Could not detect shell configuration file${NC}"
    exit 1
  fi
  
  # Check if alias already exists
  if grep -q "alias $alias_name=" "$shell_rc" 2>/dev/null; then
    echo -e "${YELLOW}‚ö†Ô∏è  Alias '$alias_name' already exists in $shell_rc${NC}"
    echo -e "${BLUE}Current alias:${NC}"
    grep "alias $alias_name=" "$shell_rc"
    read -p "Do you want to update it? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      echo -e "${BLUE}Alias installation cancelled${NC}"
      exit 0
    fi
    # Remove old alias
    sed -i "/alias $alias_name=/d" "$shell_rc"
  fi
  
  # Add new alias
  echo "" >> "$shell_rc"
  echo "# Multi-Repo Sync Script Alias" >> "$shell_rc"
  echo "alias $alias_name='$SCRIPT_PATH'" >> "$shell_rc"
  
  echo -e "${GREEN}‚úì Alias created successfully!${NC}"
  echo ""
  echo -e "${BLUE}Added to: ${YELLOW}$shell_rc${NC}"
  echo -e "${CYAN}Alias name: ${YELLOW}$alias_name${NC}"
  echo -e "${CYAN}Command: ${YELLOW}$SCRIPT_PATH${NC}"
  echo ""
  echo -e "${BLUE}Reload your shell or run:${NC} ${YELLOW}source $shell_rc${NC}"
  echo ""
  exit 0
}

# Find matching branch in repository
find_branch() {
  local repo_path="$1"
  local pattern="$2"
  local repo_key="$3"  # Repository key for better error messages
  
  cd "$repo_path"
  git fetch origin --prune --quiet 2>&1
  
  # Try exact match in remote first
  if git show-ref --verify --quiet "refs/remotes/origin/$pattern"; then
    echo "$pattern"
    return 0
  fi
  
  # Search for branches starting with the pattern (ONLY in remote)
  local remote_branches=$(git branch -r | grep -E "^\s*origin/${pattern}" | sed 's/^\s*origin\///' | sort -u)
  
  if [ -z "$remote_branches" ]; then
    # Check if branch exists locally but not in remote (exact match or pattern match)
    local local_branches=$(git branch | grep -E "^\s*\*?\s*${pattern}" | sed 's/^\s*\*\?\s*//' | sort -u)
    
    if [ -n "$local_branches" ]; then
      echo -e "    ${YELLOW}Branch exists locally but was deleted from remote${NC}" >&2
      echo "$local_branches" | while read -r branch; do
        echo -e "      ${CYAN}‚Ä¢ $branch${NC}" >&2
      done
      return 3  # Special return code for deleted remote branch
    fi
    return 1
  fi
  
  # Check if there are multiple matches
  local branch_count=$(echo "$remote_branches" | wc -l)
  if [ "$branch_count" -gt 1 ]; then
    # Show error immediately for this repository
    echo -e "    ${RED}‚úó Multiple branches found matching '$pattern'${NC}" >&2
    echo "" >&2
    echo -e "${YELLOW}    Available branches in $repo_key:${NC}" >&2
    echo "$remote_branches" | while read -r branch; do
      echo -e "      ${CYAN}‚Ä¢ $branch${NC}" >&2
    done
    echo "" >&2
    return 2
  fi
  
  # Return single match
  echo "$remote_branches"
  return 0
}

# Parse command line arguments
POSITIONAL_ARGS=()

while [[ $# -gt 0 ]]; do
  case $1 in
    -h|--help)
      show_help
      ;;
    -v|--version)
      show_version
      ;;
    -i|--install)
      CREATE_ALIAS=true
      shift
      ;;
    -c|--configure)
      CONFIGURE=true
      shift
      ;;
    -s|--show-config)
      show_config
      exit 0
      ;;
    --status|status)
      SHOW_STATUS=true
      shift
      ;;
    -d|--dependencies)
      INSTALL_DEPS=true
      shift
      ;;
    --dry-run)
      DRY_RUN=true
      shift
      ;;
    -b|--branch)
      BRANCH_PATTERN="$2"
      shift 2
      ;;
    -*)
      echo -e "${RED}‚ùå Unknown option: $1${NC}"
      echo "Use -h or --help for usage information"
      exit 1
      ;;
    *)
      POSITIONAL_ARGS+=("$1")
      shift
      ;;
  esac
done

# Handle --configure flag
if [ "$CONFIGURE" = true ]; then
  configure_repos
  exit 0
fi

# Handle --status flag
if [ "$SHOW_STATUS" = true ]; then
  show_status
fi

# Handle --install flag
if [ "$CREATE_ALIAS" = true ]; then
  create_alias
fi

# Load configuration or create default
if ! load_config; then
  echo -e "${YELLOW}‚ö†Ô∏è  Configuration file not found: $CONFIG_FILE${NC}"
  echo -e "${CYAN}Creating default configuration...${NC}"
  echo ""
  
  read -p "Do you want to configure interactively? (Y/n): " -n 1 -r
  echo ""
  
  if [[ $REPLY =~ ^[Yy]$ ]] || [ -z "$REPLY" ]; then
    configure_repos
    load_config
  else
    create_default_config
    load_config
    echo -e "${GREEN}‚úì Default configuration created${NC}"
    echo -e "${YELLOW}Edit the file to customize: ${CYAN}$CONFIG_FILE${NC}"
    echo ""
  fi
fi

# Build list of active repositories
ACTIVE_REPOS=()
for key in "${REPO_ORDER[@]}"; do
  if [ "${REPO_ENABLED[$key]}" = "true" ]; then
    ACTIVE_REPOS+=("$key")
  fi
done

if [ ${#ACTIVE_REPOS[@]} -eq 0 ]; then
  echo -e "${RED}‚ùå No repositories enabled in configuration${NC}"
  echo -e "${YELLOW}Run: multi-repo-sync --configure${NC}"
  exit 1
fi

# Set branch pattern from positional argument if not set by flag
if [ -z "$BRANCH_PATTERN" ] && [ ${#POSITIONAL_ARGS[@]} -gt 0 ]; then
  BRANCH_PATTERN="${POSITIONAL_ARGS[0]}"
fi

# Validation
if [ -z "$BRANCH_PATTERN" ]; then
  echo -e "${RED}‚ùå Error: Branch pattern not provided${NC}"
  echo "Usage: multi-repo-sync <branch-pattern> [options]"
  echo "Use -h or --help for more information"
  exit 1
fi

# Check for uncommitted changes in repository
check_uncommitted_changes() {
  local repo_path="$1"
  cd "$repo_path"
  
  # Check for uncommitted changes (staged and unstaged)
  if ! git diff-index --quiet HEAD 2>/dev/null || [ -n "$(git ls-files --others --exclude-standard)" ]; then
    return 0  # Has changes
  fi
  return 1  # No changes
}

# Process single repository (for parallel execution)
process_repo() {
  local key="$1"
  local repo="$2"
  local pattern="$3"
  local temp_dir="$4"
  local dry_run="$5"
  
  local output_file="$temp_dir/$key.output"
  local status_file="$temp_dir/$key.status"
  local branch_file="$temp_dir/$key.branch"
  local error_file="$temp_dir/$key.error"
  
  cd "$repo"
  
  # Find matching branch (stderr goes to error_file, stdout is captured)
  set +e
  matched_branch=$(find_branch "$repo" "$pattern" "$key" 2>"$error_file")
  find_status=$?
  set -e
  
  # Check for multiple branches
  if [ $find_status -eq 2 ]; then
    echo "ERROR_MULTIPLE" > "$output_file"
    echo "2" > "$status_file"
    return 2
  fi
  
  # Check if branch was deleted from remote
  if [ $find_status -eq 3 ]; then
    echo "ERROR_DELETED_REMOTE" > "$output_file"
    echo "3" > "$status_file"
    return 3
  fi
  
  if [ -z "$matched_branch" ] || [ $find_status -eq 1 ]; then
    echo "ERROR_NOT_FOUND" > "$output_file"
    echo "1" > "$status_file"
    return 1
  fi
  
  # Save matched branch
  echo "$matched_branch" > "$branch_file"
  
  # If dry-run mode, just report what would happen
  if [ "$dry_run" = "true" ]; then
    echo "DRY_RUN_WOULD_CHECKOUT" > "$output_file"
    echo "0" > "$status_file"
    return 0
  fi
  
  # Run checkout and pull in a subshell (set +e to ensure status_file is always written)
  set +e
  (
    # Checkout branch
    if git show-ref --verify --quiet "refs/heads/$matched_branch"; then
      git checkout "$matched_branch" 2>&1
    else
      git checkout -b "$matched_branch" "origin/$matched_branch" 2>&1
    fi
    
    checkout_status=$?
    
    if [ $checkout_status -ne 0 ]; then
      echo "ERROR_CHECKOUT_FAILED"
      exit 4
    fi
    
    # Get commit counts before pull
    local_commit=$(git rev-parse HEAD 2>/dev/null)
    
    # Try to pull latest changes
    pull_output=$(git pull origin "$matched_branch" 2>&1)
    pull_status=$?
    
    # Check for specific error: remote branch deleted
    if [ "$pull_status" -ne 0 ]; then
      if echo "$pull_output" | grep -qE "no such ref was fetched|couldn't find remote ref"; then
        echo "ERROR_REMOTE_DELETED"
        echo "Git output: $pull_output" >&2
        exit 5
      elif echo "$pull_output" | grep -q "would be overwritten\|local changes"; then
        echo "WARNING_LOCAL_CHANGES"
        exit 0
      else
        echo "WARNING_PULL_ISSUES"
        echo "Git output: $pull_output" >&2
        exit 0
      fi
    fi
    
    # Get commit counts after pull
    new_commit=$(git rev-parse HEAD 2>/dev/null)
    
    # Determine what happened
    if [ "$local_commit" != "$new_commit" ]; then
      commit_count=$(git rev-list --count $local_commit..$new_commit 2>/dev/null || echo "?")
      echo "PULLED:$commit_count"
    elif echo "$pull_output" | grep -q "up to date\|Already up to date"; then
      echo "UP_TO_DATE"
    else
      echo "UPDATED"
    fi
    exit 0
  ) > "$output_file" 2>"$error_file"
  echo $? > "$status_file"
  set -e
}

echo ""
echo -e "${BLUE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
echo -e "${BLUE}‚ïë              Multi-Repo Sync                       ‚ïë${NC}"
if [ "$DRY_RUN" = true ]; then
  echo -e "${BLUE}‚ïë                  [DRY-RUN MODE]                    ‚ïë${NC}"
fi
echo -e "${BLUE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
echo ""
echo -e "${CYAN}Branch pattern:${NC} ${YELLOW}$BRANCH_PATTERN${NC}"
echo -e "${CYAN}Install dependencies:${NC} ${YELLOW}$([ "$INSTALL_DEPS" = true ] && echo "Yes" || echo "No")${NC}"
if [ "$DRY_RUN" = true ]; then
  echo -e "${CYAN}Mode:${NC} ${YELLOW}DRY-RUN (no changes will be made)${NC}"
fi
echo ""

# Check for uncommitted changes before proceeding (skip in dry-run mode)
if [ "$DRY_RUN" = false ]; then
  declare -a REPOS_WITH_CHANGES
  
  for key in "${ACTIVE_REPOS[@]}"; do
    repo="${REPO_PATHS[$key]}"
    if check_uncommitted_changes "$repo"; then
      REPOS_WITH_CHANGES+=("$key")
    fi
  done
  
  if [ ${#REPOS_WITH_CHANGES[@]} -gt 0 ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  Uncommitted changes detected in the following repositories:${NC}"
    echo ""
    for key in "${REPOS_WITH_CHANGES[@]}"; do
      repo="${REPO_PATHS[$key]}"
      echo -e "  ${YELLOW}‚óã${NC} $key"
      cd "$repo"
      
      # Show brief status
      modified=$(git diff --name-only | wc -l)
      staged=$(git diff --cached --name-only | wc -l)
      untracked=$(git ls-files --others --exclude-standard | wc -l)
      
      [ "$modified" -gt 0 ] && echo -e "    ${CYAN}Modified files: $modified${NC}"
      [ "$staged" -gt 0 ] && echo -e "    ${CYAN}Staged files: $staged${NC}"
      [ "$untracked" -gt 0 ] && echo -e "    ${CYAN}Untracked files: $untracked${NC}"
    done
    echo ""
    echo -e "${CYAN}What would you like to do?${NC}"
    echo -e "  ${YELLOW}1)${NC} Stash changes and continue"
    echo -e "  ${YELLOW}2)${NC} Abort (keep working on current changes)"
    echo -e "  ${YELLOW}3)${NC} Continue anyway (may cause checkout to fail)"
    echo ""
    read -p "Choice [1/2/3]: " -n 1 -r
    echo ""
    echo ""
    
    case $REPLY in
      1)
        echo -e "${CYAN}Stashing changes...${NC}"
        for key in "${REPOS_WITH_CHANGES[@]}"; do
          repo="${REPO_PATHS[$key]}"
          cd "$repo"
          current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
          stash_msg="multi-repo-sync: auto-stash before switching to $BRANCH_PATTERN (from $current_branch)"
          git stash push -u -m "$stash_msg" 2>&1 | grep -v "No local changes to save" || true
          echo -e "  ${GREEN}‚úì${NC} Stashed $key"
        done
        echo ""
        echo -e "${GREEN}‚úì All changes stashed${NC}"
        echo -e "${CYAN}üí° To restore: ${YELLOW}git stash pop${NC} in each repository"
        echo ""
        ;;
      2)
        echo -e "${BLUE}Aborted. No changes made.${NC}"
        exit 0
        ;;
      3)
        echo -e "${YELLOW}‚ö†Ô∏è  Continuing with uncommitted changes...${NC}"
        echo ""
        ;;
      *)
        echo -e "${RED}Invalid choice. Aborting.${NC}"
        exit 1
        ;;
    esac
  fi
fi

# Step 1: Checkout and fetch/pull all repositories (in parallel)
echo -e "${BLUE}üì¶ Step 1: Updating repositories (parallel mode)...${NC}"
declare -A REPO_BRANCHES

# Create temporary directory for parallel execution
TEMP_DIR=$(mktemp -d)
trap "rm -rf $TEMP_DIR" EXIT

# Validate all repos exist first
for key in "${ACTIVE_REPOS[@]}"; do
  repo="${REPO_PATHS[$key]}"
  if [ ! -d "$repo" ]; then
    echo -e "${RED}‚ùå Repository not found: $repo${NC}"
    echo -e "${YELLOW}   Configure the correct path with: multi-repo-sync --configure${NC}"
    exit 1
  fi
done

# Launch all repository updates in parallel
if [ "$DRY_RUN" = true ]; then
  echo -e "${CYAN}Checking what would happen...${NC}"
else
  echo -e "${CYAN}Starting parallel updates...${NC}"
fi
for key in "${ACTIVE_REPOS[@]}"; do
  repo="${REPO_PATHS[$key]}"
  process_repo "$key" "$repo" "$BRANCH_PATTERN" "$TEMP_DIR" "$DRY_RUN" &
done

# Wait for all background jobs to complete
wait

echo ""

# Track successful and failed repositories
declare -a SUCCESSFUL_REPOS
declare -a FAILED_REPOS
declare -A FAILURE_REASONS

# Process results in order
for key in "${ACTIVE_REPOS[@]}"; do
  repo="${REPO_PATHS[$key]}"
  output_file="$TEMP_DIR/$key.output"
  status_file="$TEMP_DIR/$key.status"
  branch_file="$TEMP_DIR/$key.branch"
  error_file="$TEMP_DIR/$key.error"
  
  echo -e "${YELLOW}  ‚Üí $key${NC}"
  
  if [ ! -f "$status_file" ]; then
    echo -e "    ${RED}‚úó Processing failed${NC}"
    
    # Try to show error details
    if [ -f "$error_file" ] && [ -s "$error_file" ]; then
      echo ""
      cat "$error_file"
      echo ""
    elif [ -f "$output_file" ] && [ -s "$output_file" ]; then
      echo -e "    ${YELLOW}Details:${NC}"
      tail -5 "$output_file" | sed 's/^/      /'
    else
      echo -e "    ${YELLOW}No error details available. Repo: $repo${NC}"
    fi
    
    FAILED_REPOS+=("$key")
    FAILURE_REASONS["$key"]="Processing failed"
    continue
  fi
  
  exit_status=$(cat "$status_file")
  result=$(cat "$output_file" 2>/dev/null | tail -1)
  
  # Check for errors
  if [ "$result" = "ERROR_MULTIPLE" ]; then
    echo -e "    ${YELLOW}‚óã Multiple branches found${NC}"
    echo ""
    
    # Show error details
    if [ -f "$error_file" ] && [ -s "$error_file" ]; then
      cat "$error_file"
    fi
    
    FAILED_REPOS+=("$key")
    FAILURE_REASONS["$key"]="Multiple branches match pattern '$BRANCH_PATTERN'"
    continue
  fi
  
  if [ "$result" = "ERROR_REMOTE_DELETED" ] || [ "$result" = "ERROR_DELETED_REMOTE" ]; then
    echo -e "    ${YELLOW}‚óã Branch deleted from remote (only exists locally)${NC}"
    
    # Show git error details
    if [ -f "$error_file" ] && [ -s "$error_file" ]; then
      echo -e "    ${CYAN}Git:${NC}"
      cat "$error_file" | sed 's/^/      /'
    fi
    
    FAILED_REPOS+=("$key")
    FAILURE_REASONS["$key"]="Branch deleted from remote (only exists locally)"
    continue
  fi
  
  if [ "$result" = "ERROR_NOT_FOUND" ]; then
    echo -e "    ${YELLOW}‚óã Branch not found in this repository${NC}"
    FAILED_REPOS+=("$key")
    FAILURE_REASONS["$key"]="Branch '$BRANCH_PATTERN' not found"
    continue
  fi
  
  # Show branch found
  if [ -f "$branch_file" ]; then
    matched_branch=$(cat "$branch_file")
    echo -e "    ${BLUE}Found: ${YELLOW}$matched_branch${NC}"
    REPO_BRANCHES["$key"]="$matched_branch"
  fi
  
  # Show update status
  case "$result" in
    DRY_RUN_WOULD_CHECKOUT)
      echo -e "    ${CYAN}‚Üí Would checkout and pull${NC}"
      SUCCESSFUL_REPOS+=("$key")
      ;;
    PULLED:*)
      commit_count=$(echo "$result" | cut -d: -f2)
      echo -e "    ${GREEN}‚úì Pulled $commit_count commit(s)${NC}"
      SUCCESSFUL_REPOS+=("$key")
      ;;
    UP_TO_DATE)
      echo -e "    ${GREEN}‚úì Already up to date${NC}"
      SUCCESSFUL_REPOS+=("$key")
      ;;
    UPDATED)
      echo -e "    ${GREEN}‚úì Updated${NC}"
      SUCCESSFUL_REPOS+=("$key")
      ;;
    WARNING_LOCAL_CHANGES)
      echo -e "    ${YELLOW}‚ö† Checkout ok, but can't pull (local changes)${NC}"
      SUCCESSFUL_REPOS+=("$key")
      ;;
    WARNING_PULL_ISSUES)
      echo -e "    ${YELLOW}‚ö† Checkout ok, pull had issues${NC}"
      SUCCESSFUL_REPOS+=("$key")
      ;;
    *)
      echo -e "    ${YELLOW}‚ö† Unknown status${NC}"
      FAILED_REPOS+=("$key")
      FAILURE_REASONS["$key"]="Unknown status"
      ;;
  esac
done

# Check if any repositories were successfully updated
if [ ${#SUCCESSFUL_REPOS[@]} -eq 0 ]; then
  echo ""
  echo -e "${RED}‚ùå No repositories were updated successfully!${NC}"
  echo ""
  echo -e "${YELLOW}Reasons:${NC}"
  for key in "${FAILED_REPOS[@]}"; do
    echo -e "  ${RED}‚úó${NC} $key: ${FAILURE_REASONS[$key]}"
  done
  echo ""
  exit 1
fi

echo ""

# Step 2: Install dependencies (optional)
if [ "$INSTALL_DEPS" = true ] && [ "$DRY_RUN" = false ]; then
  # Identify repository types
  lib_repo=""
  api_repos=()
  front_repo=""
  
  for key in "${ACTIVE_REPOS[@]}"; do
    case "$key" in
      lib-domain|*lib*)
        lib_repo="${REPO_PATHS[$key]}"
        ;;
      frontend|*front*)
        front_repo="${REPO_PATHS[$key]}"
        ;;
      api-*|*api*)
        api_repos+=("${REPO_PATHS[$key]}")
        ;;
    esac
  done
  
  # Install library dependencies
  if [ -n "$lib_repo" ] && [ -d "$lib_repo" ]; then
    echo -e "${BLUE}üìö Step 2: Installing library dependencies...${NC}"
    cd "$lib_repo"
    if [ -f "setup.py" ]; then
      pip install -e . -q
      echo -e "${GREEN}‚úì Library installed${NC}"
      echo ""
    fi
  fi
  
  # Install API dependencies
  if [ ${#api_repos[@]} -gt 0 ]; then
    echo -e "${BLUE}üîß Step 3: Installing API dependencies...${NC}"
    for repo in "${api_repos[@]}"; do
      repo_name=$(basename "$repo")
      echo -e "${YELLOW}  ‚Üí $repo_name${NC}"
      cd "$repo"
      if [ -f "requirements.txt" ]; then
        pip install -r requirements.txt -q
        echo -e "    ${GREEN}‚úì Dependencies installed${NC}"
      else
        echo -e "    ${YELLOW}‚ö† No requirements.txt found${NC}"
      fi
    done
    echo ""
  fi
  
  # Install frontend dependencies
  if [ -n "$front_repo" ] && [ -d "$front_repo" ]; then
    echo -e "${BLUE}üé® Step 4: Installing frontend dependencies...${NC}"
    cd "$front_repo"
    if [ -f "package.json" ]; then
      npm install --silent
      echo -e "${GREEN}‚úì Frontend dependencies installed${NC}"
    else
      echo -e "${YELLOW}‚ö† No package.json found${NC}"
    fi
    echo ""
  fi
elif [ "$INSTALL_DEPS" = true ] && [ "$DRY_RUN" = true ]; then
  echo -e "${CYAN}üí° Would install dependencies (skipped in dry-run mode)${NC}"
  echo ""
fi

# Final summary
if [ "$DRY_RUN" = true ]; then
  if [ ${#FAILED_REPOS[@]} -eq 0 ]; then
    echo -e "${CYAN}‚úì Dry-run completed successfully!${NC}"
    echo -e "${CYAN}  All repositories would be updated. Run without --dry-run to apply changes.${NC}"
  else
    echo -e "${YELLOW}‚ö†Ô∏è  Dry-run completed with some warnings${NC}"
  fi
else
  if [ ${#FAILED_REPOS[@]} -eq 0 ]; then
    echo -e "${GREEN}‚úì Synchronization completed successfully!${NC}"
  else
    echo -e "${YELLOW}‚ö†Ô∏è  Synchronization completed with some warnings${NC}"
  fi
fi
echo ""

echo -e "${BLUE}üìã Current branch in each repository:${NC}"
for key in "${ACTIVE_REPOS[@]}"; do
  repo="${REPO_PATHS[$key]}"
  
  # Check if this repo was successful
  if [[ " ${SUCCESSFUL_REPOS[@]} " =~ " ${key} " ]]; then
    cd "$repo"
    current_branch=$(git rev-parse --abbrev-ref HEAD)
    echo -e "  ${GREEN}‚úì${NC} $(printf '%-25s' "$key"): ${YELLOW}$current_branch${NC}"
  else
    echo -e "  ${YELLOW}‚óã${NC} $(printf '%-25s' "$key"): ${YELLOW}${FAILURE_REASONS[$key]}${NC}"
  fi
done

# Show summary of failures if any
if [ ${#FAILED_REPOS[@]} -gt 0 ]; then
  echo ""
  echo -e "${YELLOW}‚ö†Ô∏è  Some repositories were not updated:${NC}"
  
  has_multiple_branches=false
  for key in "${FAILED_REPOS[@]}"; do
    echo -e "  ${YELLOW}‚óã${NC} $key: ${FAILURE_REASONS[$key]}"
    if [[ "${FAILURE_REASONS[$key]}" == *"Multiple branches"* ]]; then
      has_multiple_branches=true
    fi
  done
  
  # Show helpful suggestion for multiple branches
  if [ "$has_multiple_branches" = true ]; then
    echo ""
    echo -e "${CYAN}üí° Tip:${NC} Use a more specific branch pattern or the full branch name."
    echo -e "   ${BLUE}Example:${NC} mrsync feature/556-my-feature"
  fi
fi

echo ""
